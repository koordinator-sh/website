"use strict";(self.webpackChunkkoordinator_sh=self.webpackChunkkoordinator_sh||[]).push([[9634],{3905:(e,t,n)=>{n.d(t,{Zo:()=>g,kt:()=>d});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},g=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,g=o(e,["components","mdxType","originalType","parentName"]),p=u(n),c=a,d=p["".concat(s,".").concat(c)]||p[c]||m[c]||i;return n?r.createElement(d,l(l({ref:t},g),{},{components:n})):r.createElement(d,l({ref:t},g))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,l=new Array(i);l[0]=c;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[p]="string"==typeof e?e:a,l[1]=o;for(var u=2;u<i;u++)l[u]=n[u];return r.createElement.apply(null,l)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},3738:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var r=n(7462),a=(n(7294),n(3905));const i={},l="Plugin Development",o={unversionedId:"developer-guide/plugin-development",id:"developer-guide/plugin-development",title:"Plugin Development",description:"This document is generated with assistance from Qoder AI.",source:"@site/docs/developer-guide/plugin-development.md",sourceDirName:"developer-guide",slug:"/developer-guide/plugin-development",permalink:"/docs/next/developer-guide/plugin-development",draft:!1,editUrl:"https://github.com/koordinator-sh/koordinator.sh/edit/main/docs/developer-guide/plugin-development.md",tags:[],version:"current",lastUpdatedBy:"Frame",lastUpdatedAt:1760590662,formattedLastUpdatedAt:"Oct 16, 2025",frontMatter:{},sidebar:"docs",previous:{title:"Extensibility",permalink:"/docs/next/developer-guide/extensibility"},next:{title:"Custom Scheduling Policies",permalink:"/docs/next/developer-guide/custom-scheduling-policies"}},s={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Scheduler Plugin Architecture",id:"scheduler-plugin-architecture",level:2},{value:"QoS Manager Plugin Architecture",id:"qos-manager-plugin-architecture",level:2},{value:"Plugin Interface Requirements",id:"plugin-interface-requirements",level:2},{value:"Scheduler Plugin Interfaces",id:"scheduler-plugin-interfaces",level:3},{value:"QoS Manager Plugin Interfaces",id:"qos-manager-plugin-interfaces",level:3},{value:"Plugin Registration Mechanisms",id:"plugin-registration-mechanisms",level:2},{value:"Scheduler Plugin Registration",id:"scheduler-plugin-registration",level:3},{value:"QoS Manager Plugin Registration",id:"qos-manager-plugin-registration",level:3},{value:"Scheduler Plugin Implementation Example",id:"scheduler-plugin-implementation-example",level:2},{value:"Plugin Structure",id:"plugin-structure",level:3},{value:"Plugin Initialization",id:"plugin-initialization",level:3},{value:"State Management",id:"state-management",level:3},{value:"QoS Manager Plugin Implementation Example",id:"qos-manager-plugin-implementation-example",level:2},{value:"Plugin Structure",id:"plugin-structure-1",level:3},{value:"Plugin Registration",id:"plugin-registration",level:3},{value:"Development Workflow",id:"development-workflow",level:2},{value:"Plugin Creation",id:"plugin-creation",level:3},{value:"Testing",id:"testing",level:3},{value:"Deployment",id:"deployment",level:3},{value:"Lifecycle Methods and Callback Mechanisms",id:"lifecycle-methods-and-callback-mechanisms",level:2},{value:"Scheduler Plugin Lifecycle",id:"scheduler-plugin-lifecycle",level:3},{value:"QoS Manager Plugin Lifecycle",id:"qos-manager-plugin-lifecycle",level:3},{value:"Common Pitfalls and Debugging Strategies",id:"common-pitfalls-and-debugging-strategies",level:2},{value:"Common Development Pitfalls",id:"common-development-pitfalls",level:3},{value:"Debugging Strategies",id:"debugging-strategies",level:3}],g={toc:u},p="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},g,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"plugin-development"},"Plugin Development"),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"This document is generated with assistance from Qoder AI.")),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Koordinator provides a comprehensive plugin system for extending both scheduler and koordlet components. This document details the architecture, interface requirements, and development workflow for creating custom plugins. The plugin system enables developers to extend scheduling decisions and QoS policies through well-defined extension points."),(0,a.kt)("p",null,"The scheduler plugin architecture extends the Kubernetes Scheduling Framework via FrameworkExtender pattern. The QoS manager plugin system provides feature gate-based registration for implementing custom QoS policies at node level. Both systems follow consistent patterns for plugin registration, lifecycle management, and component integration."),(0,a.kt)("h2",{id:"scheduler-plugin-architecture"},"Scheduler Plugin Architecture"),(0,a.kt)("p",null,"Koordinator's scheduler plugins extend Kubernetes Scheduling Framework through FrameworkExtender interface, enhancing the base framework with Koordinator capabilities. The extender pattern allows plugins to access Koordinator resources while participating in standard scheduling."),(0,a.kt)("p",null,"FrameworkExtender key capabilities:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Access to Koordinator's custom clientset for CRD interaction"),(0,a.kt)("li",{parentName:"ul"},"Reservation nomination and restoration workflows"),(0,a.kt)("li",{parentName:"ul"},"Custom error handling filters"),(0,a.kt)("li",{parentName:"ul"},"Pod forget handlers for cleanup"),(0,a.kt)("li",{parentName:"ul"},"Scheduling transformers to modify pod/node information")),(0,a.kt)("p",null,"Plugins register during initialization and are invoked at specific extension points. FrameworkExtender manages plugin lifecycle and coordinates execution across scheduling phases."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-mermaid"},"classDiagram\nclass FrameworkExtender {\n+Scheduler() Scheduler\n+KoordinatorClientSet() Interface\n+GetReservationNominator() ReservationNominator\n+RunReservationFilterPlugins() *framework.Status\n+RunReservationScorePlugins() (PluginToReservationScores, *framework.Status)\n+RunReservationRestoreReservation() (interface{}, *framework.Status)\n}\nclass ExtendedHandle {\n+Scheduler() Scheduler\n+KoordinatorClientSet() Interface\n+GetReservationNominator() ReservationNominator\n+RegisterErrorHandlerFilters()\n+RegisterForgetPodHandler()\n}\nclass SchedulingTransformer {\n+Name() string\n}\nclass PreFilterTransformer {\n+BeforePreFilter()\n+AfterPreFilter()\n}\nclass FilterTransformer {\n+BeforeFilter()\n}\nclass ScoreTransformer {\n+BeforeScore()\n}\nFrameworkExtender <|-- ExtendedHandle\nSchedulingTransformer <|-- PreFilterTransformer\nSchedulingTransformer <|-- FilterTransformer\nSchedulingTransformer <|-- ScoreTransformer\nExtendedHandle --\x3e PreFilterTransformer\nExtendedHandle --\x3e FilterTransformer\nExtendedHandle --\x3e ScoreTransformer\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Diagram sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/scheduler/frameworkext/interface.go#L37-L55"},"interface.go"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Section sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/scheduler/frameworkext/interface.go#L37-L55"},"interface.go"))),(0,a.kt)("p",null,"The FrameworkExtender interface provides several key capabilities:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Access to Koordinator's custom clientset for interacting with CRDs"),(0,a.kt)("li",{parentName:"ul"},"Support for reservation nomination and restoration workflows"),(0,a.kt)("li",{parentName:"ul"},"Custom error handling filters for intercepting scheduling errors"),(0,a.kt)("li",{parentName:"ul"},"Pod forget handlers for cleanup operations"),(0,a.kt)("li",{parentName:"ul"},"Scheduling transformers to modify pod and node information before processing")),(0,a.kt)("p",null,"Plugins register themselves with the framework during initialization and are invoked at specific extension points throughout the scheduling cycle. The FrameworkExtender implementation manages the lifecycle of these plugins and coordinates their execution across different scheduling phases."),(0,a.kt)("h2",{id:"qos-manager-plugin-architecture"},"QoS Manager Plugin Architecture"),(0,a.kt)("p",null,"The QoS manager provides a plugin system for implementing custom QoS policies through feature gate-based registration, allowing dynamic plugin enablement/disablement."),(0,a.kt)("p",null,"Components:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ExtensionPlugin interface"),": Contract for QoS plugins (InitFlags, Setup, Run methods)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"RegisterQOSExtPlugin"),": Registers plugins with the system"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"SetupPlugins"),": Initializes plugins with dependencies"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"StartPlugins"),": Starts enabled plugins based on feature gates")),(0,a.kt)("p",null,"Plugins register using feature gates for dynamic control. The QoS manager orchestrates plugin lifecycle, ensuring proper initialization and startup."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-mermaid"},"classDiagram\nclass ExtensionPlugin {\n+InitFlags(fs *flag.FlagSet)\n+Setup(client clientset.Interface, metricCache metriccache.MetricCache, statesInformer statesinformer.StatesInformer)\n+Run(stopCh <-chan struct{})\n}\nclass QOSExtensionConfig {\n+FeatureGates map[string]bool\n+InitFlags(fs *flag.FlagSet)\n}\nclass QOSManager {\n+Run(stopCh <-chan struct{})\n}\nExtensionPlugin <|-- CustomQOSPlugin\nQOSExtensionConfig --\x3e ExtensionPlugin : configures\nQOSManager --\x3e ExtensionPlugin : manages\nQOSManager --\x3e QOSExtensionConfig : uses\nnote right of ExtensionPlugin\nInterface for QOS extension plugins\nEach plugin must implement these methods\nend\nnote right of QOSExtensionConfig\nConfiguration for QOS extension plugins\nUses feature gates to enable/disable plugins\nend\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Diagram sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/koordlet/qosmanager/framework/extension.go"},"extension.go"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Section sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/koordlet/qosmanager/framework/extension.go"},"extension.go"))),(0,a.kt)("p",null,"The QoS manager plugin system operates through the following components:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ExtensionPlugin interface"),": Defines the contract for QoS extension plugins with InitFlags, Setup, and Run methods"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"RegisterQOSExtPlugin function"),": Registers new QoS extension plugins with the system"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"SetupPlugins function"),": Initializes all registered plugins with required dependencies"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"StartPlugins function"),": Starts enabled plugins based on feature gate configuration")),(0,a.kt)("p",null,"Plugins are registered using feature gates, allowing for dynamic enablement and disablement. Each plugin must implement the ExtensionPlugin interface, which includes methods for flag initialization, setup with dependencies, and execution. The QoS manager orchestrates the lifecycle of these plugins, ensuring they are properly initialized and started."),(0,a.kt)("h2",{id:"plugin-interface-requirements"},"Plugin Interface Requirements"),(0,a.kt)("p",null,"Koordinator plugins must implement specific interfaces depending on their component and functionality. The interface requirements differ between scheduler plugins and QoS manager plugins, reflecting their distinct roles in the system."),(0,a.kt)("h3",{id:"scheduler-plugin-interfaces"},"Scheduler Plugin Interfaces"),(0,a.kt)("p",null,"Scheduler plugins in Koordinator implement interfaces that extend the Kubernetes Scheduling Framework. These interfaces correspond to different phases of the scheduling cycle:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Extension Point"),(0,a.kt)("th",{parentName:"tr",align:null},"Interface"),(0,a.kt)("th",{parentName:"tr",align:null},"Purpose"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"PreEnqueue")),(0,a.kt)("td",{parentName:"tr",align:null},"PreEnqueuePlugin"),(0,a.kt)("td",{parentName:"tr",align:null},"Early validation before scheduling begins")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"PreFilter")),(0,a.kt)("td",{parentName:"tr",align:null},"PreFilterPlugin"),(0,a.kt)("td",{parentName:"tr",align:null},"Pre-process pod and initialize cycle state")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Filter")),(0,a.kt)("td",{parentName:"tr",align:null},"FilterPlugin"),(0,a.kt)("td",{parentName:"tr",align:null},"Evaluate if node meets pod requirements")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Score")),(0,a.kt)("td",{parentName:"tr",align:null},"ScorePlugin"),(0,a.kt)("td",{parentName:"tr",align:null},"Rank nodes for pod placement")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Reserve")),(0,a.kt)("td",{parentName:"tr",align:null},"ReservePlugin"),(0,a.kt)("td",{parentName:"tr",align:null},"Reserve resources for pod")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"PreBind")),(0,a.kt)("td",{parentName:"tr",align:null},"PreBindPlugin"),(0,a.kt)("td",{parentName:"tr",align:null},"Final checks before binding")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"PostBind")),(0,a.kt)("td",{parentName:"tr",align:null},"PostBindPlugin"),(0,a.kt)("td",{parentName:"tr",align:null},"Post-binding operations")))),(0,a.kt)("p",null,"Additionally, Koordinator defines specialized interfaces for reservation handling:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ReservationFilterPlugin"),": Determines which reservations are available"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ReservationScorePlugin"),": Ranks reservations for pod placement"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ReservationRestorePlugin"),": Restores resources held by reservations"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ReservationNominator"),": Selects the most suitable reservation for a pod")),(0,a.kt)("h3",{id:"qos-manager-plugin-interfaces"},"QoS Manager Plugin Interfaces"),(0,a.kt)("p",null,"QoS manager plugins must implement the ExtensionPlugin interface, which defines the following methods:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"InitFlags"),": Initializes command-line flags for the plugin"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Setup"),": Sets up the plugin with required dependencies (clientset, metric cache, states informer)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Run"),": Starts the plugin's main execution loop")),(0,a.kt)("p",null,"Plugins are registered through the RegisterQOSExtPlugin function and are managed by the QOSManager, which handles their lifecycle based on feature gate configuration."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Section sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/koordlet/qosmanager/framework/extension.go"},"extension.go")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/koordlet/qosmanager/plugins/register.go"},"register.go"))),(0,a.kt)("h2",{id:"plugin-registration-mechanisms"},"Plugin Registration Mechanisms"),(0,a.kt)("p",null,"Koordinator uses different registration mechanisms for scheduler plugins and QoS manager plugins, reflecting their distinct initialization processes and component architectures."),(0,a.kt)("h3",{id:"scheduler-plugin-registration"},"Scheduler Plugin Registration"),(0,a.kt)("p",null,"Scheduler plugins are registered through the main.go file in the koord-scheduler component. The registration process involves:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Defining a map of plugin names to factory functions"),(0,a.kt)("li",{parentName:"ol"},"Flattening the plugin map into options for the scheduler command"),(0,a.kt)("li",{parentName:"ol"},"Registering the plugins during scheduler initialization")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-mermaid"},'flowchart TD\nStart([Plugin Registration]) --\x3e DefineMap["Define Plugin Map"]\nDefineMap --\x3e Flatten["Flatten to Options"]\nFlatten --\x3e Register["Register with Scheduler"]\nRegister --\x3e Initialize["Initialize During Startup"]\nInitialize --\x3e End([Plugins Ready])\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Diagram sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/cmd/koord-scheduler/main.go#L43-L79"},"main.go")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/cmd/koord-scheduler/app/server.go#L357-L391"},"server.go"))),(0,a.kt)("p",null,"The registration process in code:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"var koordinatorPlugins = map[string]frameworkruntime.PluginFactory{\n    loadaware.Name:               loadaware.New,\n    nodenumaresource.Name:        nodenumaresource.New,\n    reservation.Name:             reservation.New,\n    coscheduling.Name:            coscheduling.New,\n    deviceshare.Name:             deviceshare.New,\n    elasticquota.Name:            elasticquota.New,\n    defaultprebind.Name:          defaultprebind.New,\n    noderesourcesfitplus.Name:    noderesourcesfitplus.New,\n    scarceresourceavoidance.Name: scarceresourceavoidance.New,\n}\n")),(0,a.kt)("h3",{id:"qos-manager-plugin-registration"},"QoS Manager Plugin Registration"),(0,a.kt)("p",null,"QoS manager plugins are registered through a feature gate-based system that allows for dynamic enablement and disablement. The registration process involves:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Calling RegisterQOSExtPlugin with the plugin implementation"),(0,a.kt)("li",{parentName:"ol"},"Configuring feature gates to enable/disable specific plugins"),(0,a.kt)("li",{parentName:"ol"},"Initializing plugins during koordlet startup"),(0,a.kt)("li",{parentName:"ol"},"Starting enabled plugins based on configuration")),(0,a.kt)("p",null,"The registration system uses a global registry to store plugin implementations and manages their lifecycle through the QOSManager component."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Section sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/koordlet/qosmanager/plugins/register.go"},"register.go")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/koordlet/qosmanager/framework/extension.go"},"extension.go"))),(0,a.kt)("h2",{id:"scheduler-plugin-implementation-example"},"Scheduler Plugin Implementation Example"),(0,a.kt)("p",null,"Creating a custom scheduler plugin in Koordinator follows a standardized pattern that ensures compatibility with the existing scheduling infrastructure. The implementation structure includes the plugin type, factory function, and scheduling cycle interface implementations."),(0,a.kt)("h3",{id:"plugin-structure"},"Plugin Structure"),(0,a.kt)("p",null,"A typical scheduler plugin in Koordinator follows this structure:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},'type Plugin struct {\n    handle framework.Handle\n    // plugin-specific fields\n}\n\nfunc New(args runtime.Object, handle framework.Handle) (framework.Plugin, error) {\n    // Initialize plugin with configuration and handle\n}\n\nfunc (p *Plugin) Name() string {\n    return "PluginName"\n}\n\n// Implement scheduling cycle interfaces\nfunc (p *Plugin) PreFilter(...) {...}\nfunc (p *Plugin) Filter(...) {...}\nfunc (p *Plugin) Score(...) {...}\nfunc (p *Plugin) Reserve(...) {...}\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Section sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/scheduler/plugins/loadaware/load_aware.go#L71-L79"},"load_aware.go")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/scheduler/plugins/elasticquota/plugin.go#L74-L93"},"elasticquota/plugin.go"))),(0,a.kt)("h3",{id:"plugin-initialization"},"Plugin Initialization"),(0,a.kt)("p",null,"The New function serves as the entry point for plugin creation and handles:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Configuration parsing from the runtime.Object parameter"),(0,a.kt)("li",{parentName:"ul"},"Validation of configuration parameters"),(0,a.kt)("li",{parentName:"ul"},"Dependency injection through the framework handle"),(0,a.kt)("li",{parentName:"ul"},"Event registration for cluster events the plugin needs to monitor")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-mermaid"},'flowchart TD\nStart([Plugin Initialization]) --\x3e ParseConfig["Parse Configuration Object"]\nParseConfig --\x3e ValidateConfig["Validate Configuration"]\nValidateConfig --\x3e CreateClient["Create Clientset if needed"]\nCreateClient --\x3e SetupInformer["Setup Shared Informers"]\nSetupInformer --\x3e RegisterHandlers["Register Event Handlers"]\nRegisterHandlers --\x3e RegisterForgetHandler["Register ForgetPodHandler"]\nRegisterForgetHandler --\x3e ReturnPlugin["Return Plugin Instance"]\nReturnPlugin --\x3e End([Plugin Ready])\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Diagram sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/scheduler/plugins/reservation/plugin.go#L93-L104"},"plugin.go"))),(0,a.kt)("h3",{id:"state-management"},"State Management"),(0,a.kt)("p",null,"Plugins use cycle state to maintain data across different scheduling phases. The cycle state is a thread-safe storage mechanism that allows plugins to share information:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"func getStateData(cycleState *framework.CycleState) *stateData {\n    v, err := cycleState.Read(stateKey)\n    if err != nil {\n        return &stateData{}\n    }\n    s, ok := v.(*stateData)\n    if !ok || s == nil {\n        return &stateData{}\n    }\n    return s\n}\n")),(0,a.kt)("p",null,"Best practices for state management include using unique keys, implementing proper synchronization, cleaning up state in appropriate phases, and cloning state when necessary to prevent unintended modifications."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Section sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/scheduler/plugins/reservation/reservation_state.go#L143-L162"},"reservation_state.go"))),(0,a.kt)("h2",{id:"qos-manager-plugin-implementation-example"},"QoS Manager Plugin Implementation Example"),(0,a.kt)("p",null,"Creating a custom QoS manager plugin involves implementing the ExtensionPlugin interface and registering the plugin with the QoS manager system. The implementation follows a consistent pattern across all QoS extension plugins."),(0,a.kt)("h3",{id:"plugin-structure-1"},"Plugin Structure"),(0,a.kt)("p",null,"A QoS manager plugin must implement the ExtensionPlugin interface with the following methods:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go"},"type ExtensionPlugin interface {\n    InitFlags(fs *flag.FlagSet)\n    Setup(client clientset.Interface, metricCache metriccache.MetricCache, statesInformer statesinformer.StatesInformer)\n    Run(stopCh <-chan struct{})\n}\n")),(0,a.kt)("p",null,"Each method serves a specific purpose in the plugin lifecycle:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"InitFlags"),": Registers command-line flags specific to the plugin"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Setup"),": Initializes the plugin with dependencies from the koordlet"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Run"),": Executes the plugin's main logic in a goroutine")),(0,a.kt)("h3",{id:"plugin-registration"},"Plugin Registration"),(0,a.kt)("p",null,"QoS manager plugins are registered through the RegisterQOSExtPlugin function, which adds the plugin to the global registry. The registration process ensures that each plugin has a unique name and is properly integrated into the QoS manager system."),(0,a.kt)("p",null,"Plugins are enabled or disabled through feature gates in the koordlet configuration, allowing for dynamic control over which QoS policies are active in the cluster."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Section sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/koordlet/qosmanager/framework/extension.go"},"extension.go")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/koordlet/qosmanager/plugins/register.go"},"register.go"))),(0,a.kt)("h2",{id:"development-workflow"},"Development Workflow"),(0,a.kt)("p",null,"The complete development workflow for creating custom plugins in Koordinator involves several stages from creation to deployment. This workflow ensures that plugins are properly integrated, tested, and deployed in production environments."),(0,a.kt)("h3",{id:"plugin-creation"},"Plugin Creation"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Define the plugin structure"),": Create a struct that holds the plugin's state and dependencies"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Implement the required interfaces"),": Implement the appropriate interfaces for the plugin type"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Create the factory function"),": Implement the New function that initializes the plugin"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Register the plugin"),": Add the plugin to the appropriate registration system")),(0,a.kt)("h3",{id:"testing"},"Testing"),(0,a.kt)("p",null,"Koordinator provides comprehensive testing utilities for both scheduler and QoS manager plugins:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Unit tests for individual plugin methods"),(0,a.kt)("li",{parentName:"ul"},"Integration tests with the full scheduling cycle"),(0,a.kt)("li",{parentName:"ul"},"End-to-end tests for complete workflows"),(0,a.kt)("li",{parentName:"ul"},"Benchmarking for performance evaluation")),(0,a.kt)("p",null,"Test utilities include mock informers for CRDs and Kubernetes resources, test fixtures for common scenarios, assertion helpers for validating decisions, and performance measurement tools."),(0,a.kt)("h3",{id:"deployment"},"Deployment"),(0,a.kt)("p",null,"Plugins are deployed as part of the koord-scheduler or koordlet components:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Scheduler plugins are included in the koord-scheduler binary"),(0,a.kt)("li",{parentName:"ul"},"QoS manager plugins are included in the koordlet binary"),(0,a.kt)("li",{parentName:"ul"},"Configuration is managed through component configuration files"),(0,a.kt)("li",{parentName:"ul"},"Feature gates control plugin enablement")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Section sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/cmd/koord-scheduler/main.go#L43-L79"},"main.go")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/cmd/koord-scheduler/app/server.go#L419-L489"},"server.go"))),(0,a.kt)("h2",{id:"lifecycle-methods-and-callback-mechanisms"},"Lifecycle Methods and Callback Mechanisms"),(0,a.kt)("p",null,"Koordinator plugins have well-defined lifecycle methods and callback mechanisms that enable them to participate in various stages of the system's operation."),(0,a.kt)("h3",{id:"scheduler-plugin-lifecycle"},"Scheduler Plugin Lifecycle"),(0,a.kt)("p",null,"Scheduler plugins participate in the scheduling cycle through extension point callbacks:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"PreEnqueue"),": Called early in the scheduling process for validation"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"PreFilter"),": Called to pre-process pod information and initialize state"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Filter"),": Called to evaluate if nodes meet pod requirements"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Score"),": Called to rank suitable nodes for pod placement"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Reserve"),": Called to temporarily reserve resources on the selected node"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"PreBind"),": Called for final validation before binding"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"PostBind"),": Called for post-binding operations and cleanup")),(0,a.kt)("p",null,"Plugins can also implement specialized lifecycle methods for reservation handling:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"PreRestoreReservation"),": Called before restoring resources held by reservations"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"RestoreReservation"),": Called to restore fine-grained resources during scheduling"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"FilterReservation"),": Called to determine which reservations are available"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"ScoreReservation"),": Called to rank reservations for pod placement")),(0,a.kt)("h3",{id:"qos-manager-plugin-lifecycle"},"QoS Manager Plugin Lifecycle"),(0,a.kt)("p",null,"QoS manager plugins follow a different lifecycle pattern:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"InitFlags"),": Called during koordlet startup to register command-line flags"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Setup"),": Called to initialize the plugin with dependencies"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Run"),": Called to start the plugin's main execution loop"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Stop"),": Called during shutdown to clean up resources")),(0,a.kt)("p",null,"The QoS manager uses callback mechanisms to notify plugins of state changes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"RegisterCallbacks"),": Registers update callbacks for specific object types"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"SendCallback"),": Triggers callbacks when state changes occur"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"UpdateCbFn"),": The callback function type that plugins implement")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Section sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/scheduler/frameworkext/interface.go#L37-L55"},"interface.go")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/koordlet/qosmanager/framework/extension.go"},"extension.go"))),(0,a.kt)("h2",{id:"common-pitfalls-and-debugging-strategies"},"Common Pitfalls and Debugging Strategies"),(0,a.kt)("p",null,"Developing plugins for Koordinator requires attention to common pitfalls and effective debugging strategies to ensure reliable and performant operation."),(0,a.kt)("h3",{id:"common-development-pitfalls"},"Common Development Pitfalls"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"State Management Issues"),": Improper state management can lead to race conditions and memory leaks"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Error Handling"),": Inadequate error handling can cause silent failures in the scheduler"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Resource Leaks"),": Failure to clean up resources can lead to memory exhaustion"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Thread Safety"),": Concurrent access to shared data structures without proper synchronization"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Configuration Validation"),": Insufficient validation of plugin configuration parameters")),(0,a.kt)("h3",{id:"debugging-strategies"},"Debugging Strategies"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Logging"),": Enable verbose logging for specific plugins during development"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Metrics"),": Monitor Prometheus metrics to identify performance bottlenecks"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Diagnosis Information"),": Analyze failure reasons in PostFilter to understand scheduling rejections"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Event Tracing"),": Use event tracing to understand the sequence of plugin execution"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Unit Testing"),": Write comprehensive unit tests for all plugin methods"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Integration Testing"),": Test plugins in integration environments that simulate production workloads")),(0,a.kt)("p",null,"Best practices for debugging include:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Using the cycle state for debugging information storage"),(0,a.kt)("li",{parentName:"ul"},"Implementing comprehensive logging at different verbosity levels"),(0,a.kt)("li",{parentName:"ul"},"Monitoring plugin-specific metrics for performance analysis"),(0,a.kt)("li",{parentName:"ul"},"Using the framework's built-in debugging tools and utilities"),(0,a.kt)("li",{parentName:"ul"},"Testing edge cases and failure scenarios thoroughly")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Section sources")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/scheduler/plugins/reservation/plugin.go"},"plugin.go")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/scheduler/plugins/loadaware/load_aware.go"},"load_aware.go")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/tree/main/pkg/scheduler/plugins/elasticquota/plugin.go"},"elasticquota/plugin.go"))))}m.isMDXComponent=!0}}]);