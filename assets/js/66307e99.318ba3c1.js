"use strict";(self.webpackChunkkoordinator_sh=self.webpackChunkkoordinator_sh||[]).push([[2730],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>g});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)t=r[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var p=o.createContext({}),s=function(e){var n=o.useContext(p),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},d=function(e){var n=s(e.components);return o.createElement(p.Provider,{value:n},e.children)},m="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},c=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,r=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=s(t),c=a,g=m["".concat(p,".").concat(c)]||m[c]||u[c]||r;return t?o.createElement(g,i(i({ref:n},d),{},{components:t})):o.createElement(g,i({ref:n},d))}));function g(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var r=t.length,i=new Array(r);i[0]=c;var l={};for(var p in n)hasOwnProperty.call(n,p)&&(l[p]=n[p]);l.originalType=e,l[m]="string"==typeof e?e:a,i[1]=l;for(var s=2;s<r;s++)i[s]=t[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,t)}c.displayName="MDXCreateElement"},94858:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>p,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var o=t(87462),a=(t(67294),t(3905));const r={},i="Network Topology Aware",l={unversionedId:"user-manuals/network-topology-aware-scheduling",id:"version-v1.7/user-manuals/network-topology-aware-scheduling",title:"Network Topology Aware",description:"Introduction",source:"@site/versioned_docs/version-v1.7/user-manuals/network-topology-aware-scheduling.md",sourceDirName:"user-manuals",slug:"/user-manuals/network-topology-aware-scheduling",permalink:"/docs/user-manuals/network-topology-aware-scheduling",draft:!1,editUrl:"https://github.com/koordinator-sh/koordinator.sh/edit/main/docs/user-manuals/network-topology-aware-scheduling.md",tags:[],version:"v1.7",lastUpdatedBy:"\u4e54\u666e",lastUpdatedAt:1761892389,formattedLastUpdatedAt:"Oct 31, 2025",frontMatter:{},sidebar:"docs",previous:{title:"Job Level Preemption",permalink:"/docs/user-manuals/job-level-preemption"},next:{title:"Capacity Scheduling - Elastic Quota Management",permalink:"/docs/user-manuals/capacity-scheduling"}},p={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Prerequisites",id:"prerequisites",level:2},{value:"Verify Network Topology Support is Enabled",id:"verify-network-topology-support-is-enabled",level:2},{value:"Check koord-scheduler Startup Parameters",id:"check-koord-scheduler-startup-parameters",level:3},{value:"Check Coscheduling Plugin Configuration",id:"check-coscheduling-plugin-configuration",level:3},{value:"Configure Network Topology",id:"configure-network-topology",level:2},{value:"Label Nodes with Topology Information",id:"label-nodes-with-topology-information",level:3},{value:"Create ClusterNetworkTopology",id:"create-clusternetworktopology",level:3},{value:"Verify Topology Configuration",id:"verify-topology-configuration",level:3},{value:"Usage Example",id:"usage-example",level:2},{value:"Environment Setup",id:"environment-setup",level:3},{value:"Example 1: Topology-Aware Scheduling with <code>PreferGather</code> and Binpack",id:"example-1-topology-aware-scheduling-with-prefergather-and-binpack",level:3},{value:"Scenario",id:"scenario",level:4},{value:"Step 1: Create PodGroup with <code>PreferGather</code> Strategy",id:"step-1-create-podgroup-with-prefergather-strategy",level:4},{value:"Step 2: Create 4-Pod Training Job",id:"step-2-create-4-pod-training-job",level:4},{value:"Step 3: Apply and Verify the Scheduling Result",id:"step-3-apply-and-verify-the-scheduling-result",level:4},{value:"How the Binpack Algorithm Works",id:"how-the-binpack-algorithm-works",level:4},{value:"Example 2: <code>MustGather</code> and Topology-Aware Preemption",id:"example-2-mustgather-and-topology-aware-preemption",level:3},{value:"Scenario",id:"scenario-1",level:4},{value:"Step 1: Define PriorityClasses",id:"step-1-define-priorityclasses",level:4},{value:"Step 2: Create Low-Priority Pods on node-0, node-1, and node-5",id:"step-2-create-low-priority-pods-on-node-0-node-1-and-node-5",level:4},{value:"Step 3: Create High-Priority Job with <code>MustGather</code> to SpineLayer",id:"step-3-create-high-priority-job-with-mustgather-to-spinelayer",level:4},{value:"Step 4: Apply and Observe Preemption",id:"step-4-apply-and-observe-preemption",level:4},{value:"Step 5: Verify Final Scheduling Result",id:"step-5-verify-final-scheduling-result",level:4},{value:"How Topology-Aware Preemption Works",id:"how-topology-aware-preemption-works",level:4},{value:"Advanced Configuration",id:"advanced-configuration",level:2},{value:"Topology Layer Naming Conventions",id:"topology-layer-naming-conventions",level:3},{value:"Topology Strategy Selection Guide",id:"topology-strategy-selection-guide",level:3},{value:"Multi-PodGroup Coordinated Scheduling",id:"multi-podgroup-coordinated-scheduling",level:3},{value:"Troubleshooting",id:"troubleshooting",level:2},{value:"Pod Stuck in Pending State",id:"pod-stuck-in-pending-state",level:3},{value:"Topology-Aware Scheduling Not Taking Effect",id:"topology-aware-scheduling-not-taking-effect",level:3},{value:"Preemption Not Occurring as Expected",id:"preemption-not-occurring-as-expected",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"References",id:"references",level:2}],d={toc:s},m="wrapper";function u(e){let{components:n,...t}=e;return(0,a.kt)(m,(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"network-topology-aware"},"Network Topology Aware"),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"In large-scale AI training scenarios, especially for large language models (LLMs), efficient inter-pod communication is critical to training performance. Model parallelism techniques such as Tensor Parallelism (TP), Pipeline Parallelism (PP), and Data Parallelism (DP) require frequent and high-bandwidth data exchange across GPUs\u2014often spanning multiple nodes. Under such workloads, ",(0,a.kt)("strong",{parentName:"p"},"network topology becomes a key performance bottleneck"),", where communication latency and bandwidth are heavily influenced by the physical network hierarchy (e.g., NVLink, block, spine)."),(0,a.kt)("p",null,"To optimize training efficiency, Koordinator provides ",(0,a.kt)("strong",{parentName:"p"},"Network-Topology Aware Scheduling")," capability, which ensures:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"When cluster resources are sufficient, pods with network topology scheduling requirements will be scheduled to topology domains with better performance (e.g., lower latency, higher bandwidth) according to user-specified strategies."),(0,a.kt)("li",{parentName:"ul"},"When cluster resources are insufficient, the scheduler will preempt resources for the GangGroup based on network topology constraints through job-level preemption, and record the resource nominations in the ",(0,a.kt)("inlineCode",{parentName:"li"},".status.nominatedNode")," field to ensure consistent placement.")),(0,a.kt)("p",null,"This capability works seamlessly with ",(0,a.kt)("a",{parentName:"p",href:"https://koordinator.sh/docs/next/architecture/job/"},"PodGroup/GangGroup")," semantics."),(0,a.kt)("h2",{id:"prerequisites"},"Prerequisites"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Kubernetes >= 1.18"),(0,a.kt)("li",{parentName:"ul"},"Koordinator >= 1.7.0")),(0,a.kt)("h2",{id:"verify-network-topology-support-is-enabled"},"Verify Network Topology Support is Enabled"),(0,a.kt)("p",null,"Although network topology aware scheduling is ",(0,a.kt)("strong",{parentName:"p"},"enabled by default")," as of Koordinator >= 1.7.0, it's recommended to confirm the configuration before proceeding."),(0,a.kt)("h3",{id:"check-koord-scheduler-startup-parameters"},"Check koord-scheduler Startup Parameters"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Verify that the koord-scheduler has the network topology manager enabled:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl -n koordinator-system get deployment koord-scheduler -o yaml | grep enable-network-topology-manager\n")),(0,a.kt)("p",null,"Expected output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"- --enable-network-topology-manager=true\n")),(0,a.kt)("p",null,"If the parameter is missing or set to ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),", update the koord-scheduler deployment to add this flag."),(0,a.kt)("h3",{id:"check-coscheduling-plugin-configuration"},"Check Coscheduling Plugin Configuration"),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"Verify that the Coscheduling plugin has network topology awareness enabled:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl -n koordinator-system get cm koord-scheduler-config -o yaml\n")),(0,a.kt)("p",null,"Ensure the Coscheduling plugin configuration includes ",(0,a.kt)("inlineCode",{parentName:"p"},"awareNetworkTopology: true"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: koord-scheduler-config\n  namespace: koordinator-system\ndata:\n  koord-scheduler-config: |\n    apiVersion: kubescheduler.config.k8s.io/v1\n    kind: KubeSchedulerConfiguration\n    profiles:\n    - pluginConfig:\n      - name: Coscheduling\n        args:\n          apiVersion: kubescheduler.config.k8s.io/v1\n          kind: CoschedulingArgs\n          awareNetworkTopology: true\n          enablePreemption: true\n")),(0,a.kt)("p",null,"If ",(0,a.kt)("inlineCode",{parentName:"p"},"awareNetworkTopology")," is missing or set to ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),", update the ConfigMap and restart the koord-scheduler pod:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl delete po -l koord-app=koord-scheduler -n koordinator-system \n")),(0,a.kt)("h2",{id:"configure-network-topology"},"Configure Network Topology"),(0,a.kt)("h3",{id:"label-nodes-with-topology-information"},"Label Nodes with Topology Information"),(0,a.kt)("p",null,"First, use tools like NVIDIA's ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/NVIDIA/topograph/blob/v0.1.0/docs/engines/k8s.md"},"topograph")," to label nodes with their network topology positions:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Node\nmetadata:\n  name: node-0\n  labels:\n    network.topology.nvidia.com/block: b1\n    network.topology.nvidia.com/spine: s1\n")),(0,a.kt)("h3",{id:"create-clusternetworktopology"},"Create ClusterNetworkTopology"),(0,a.kt)("p",null,"Administrators define the topology hierarchy via a ",(0,a.kt)("inlineCode",{parentName:"p"},"ClusterNetworkTopology")," CR named ",(0,a.kt)("inlineCode",{parentName:"p"},"default"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: scheduling.koordinator.sh/v1alpha1\nkind: ClusterNetworkTopology\nmetadata:\n  name: default\nspec:\n  networkTopologySpec:\n    - labelKey:\n      - network.topology.nvidia.com/spine\n      topologyLayer: SpineLayer\n    - labelKey:\n      - network.topology.nvidia.com/block\n      parentTopologyLayer: SpineLayer\n      topologyLayer: BlockLayer\n    - parentTopologyLayer: BlockLayer\n      topologyLayer: NodeTopologyLayer\n")),(0,a.kt)("p",null,"The topology forms a tree structure, where each layer represents a level of aggregation in the network (e.g., Node \u2192 Block \u2192 Spine)."),(0,a.kt)("h3",{id:"verify-topology-configuration"},"Verify Topology Configuration"),(0,a.kt)("p",null,"After applying the ClusterNetworkTopology, check its status:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get clusternetworktopology default -o yaml\n")),(0,a.kt)("p",null,"Example output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'status:\n  detailStatus:\n  - childTopologyLayer: SpineLayer\n    childTopologyNames:\n    - spine-0\n    - spine-1\n    - spine-2\n    nodeNum: 12\n    topologyInfo:\n      topologyLayer: ClusterTopologyLayer\n      topologyName: ""\n  - childTopologyLayer: BlockLayer\n    childTopologyNames:\n    - block-0\n    - block-1\n    nodeNum: 5\n    parentTopologyInfo:\n      topologyLayer: ClusterTopologyLayer\n      topologyName: ""\n    topologyInfo:\n      topologyLayer: SpineLayer\n      topologyName: spine-0\n  - childTopologyLayer: NodeTopologyLayer\n    nodeNum: 3\n    parentTopologyInfo:\n      topologyLayer: SpineLayer\n      topologyName: spine-0\n    topologyInfo:\n      topologyLayer: BlockLayer\n      topologyName: block-0\n  - childTopologyLayer: NodeTopologyLayer\n    nodeNum: 2\n    parentTopologyInfo:\n      topologyLayer: SpineLayer\n      topologyName: spine-0\n    topologyInfo:\n      topologyLayer: BlockLayer\n      topologyName: block-1\n  - childTopologyLayer: BlockLayer\n    childTopologyNames:\n    - block-2\n    - block-3\n    nodeNum: 4\n    parentTopologyInfo:\n      topologyLayer: ClusterTopologyLayer\n      topologyName: ""\n    topologyInfo:\n      topologyLayer: SpineLayer\n      topologyName: spine-1\n  - childTopologyLayer: NodeTopologyLayer\n    nodeNum: 2\n    parentTopologyInfo:\n      topologyLayer: SpineLayer\n      topologyName: spine-1\n    topologyInfo:\n      topologyLayer: BlockLayer\n      topologyName: block-2\n  - childTopologyLayer: NodeTopologyLayer\n    nodeNum: 2\n    parentTopologyInfo:\n      topologyLayer: SpineLayer\n      topologyName: spine-1\n    topologyInfo:\n      topologyLayer: BlockLayer\n      topologyName: block-3\n  - childTopologyLayer: BlockLayer\n    childTopologyNames:\n    - block-4\n    nodeNum: 3\n    parentTopologyInfo:\n      topologyLayer: ClusterTopologyLayer\n      topologyName: ""\n    topologyInfo:\n      topologyLayer: SpineLayer\n      topologyName: spine-2\n  - childTopologyLayer: NodeTopologyLayer\n    nodeNum: 3\n    parentTopologyInfo:\n      topologyLayer: SpineLayer\n      topologyName: spine-2\n    topologyInfo:\n      topologyLayer: BlockLayer\n      topologyName: block-4\n')),(0,a.kt)("p",null,"Based on the above ",(0,a.kt)("inlineCode",{parentName:"p"},"status"),", the cluster has a two-tier ",(0,a.kt)("strong",{parentName:"p"},"spine-block")," architecture:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"ClusterTopologyLayer\n\u251c\u2500\u2500 SpineLayer: spine-0\n\u2502   \u251c\u2500\u2500 BlockLayer: block-0\n\u2502   \u2502   \u2514\u2500\u2500 NodeTopologyLayer: 3 nodes\n\u2502   \u2514\u2500\u2500 BlockLayer: block-1\n\u2502       \u2514\u2500\u2500 NodeTopologyLayer: 2 nodes\n\u2502\n\u251c\u2500\u2500 SpineLayer: spine-1\n\u2502   \u251c\u2500\u2500 BlockLayer: block-2\n\u2502   \u2502   \u2514\u2500\u2500 NodeTopologyLayer: 2 nodes\n\u2502   \u2514\u2500\u2500 BlockLayer: block-3\n\u2502       \u2514\u2500\u2500 NodeTopologyLayer: 2 nodes\n\u2502\n\u2514\u2500\u2500 SpineLayer: spine-2\n    \u2514\u2500\u2500 BlockLayer: block-4\n        \u2514\u2500\u2500 NodeTopologyLayer: 3 nodes\n")),(0,a.kt)("p",null,"We may have noticed that this network topology architecture is consistent with the one used in the ",(0,a.kt)("a",{parentName:"p",href:"https://koordinator.sh/docs/next/architecture/job#topology-gather-algorithm"},"network topology algorithm demonstration"),"."),(0,a.kt)("h2",{id:"usage-example"},"Usage Example"),(0,a.kt)("h3",{id:"environment-setup"},"Environment Setup"),(0,a.kt)("p",null,"To demonstrate network topology aware scheduling, we assume the cluster has the topology configuration shown in the ",(0,a.kt)("a",{parentName:"p",href:"#verify-topology-configuration"},"Verify Topology Configuration")," section:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"12 worker nodes total (node-0 through node-11)"),(0,a.kt)("li",{parentName:"ul"},"3 Spines:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"spine-0: 5 nodes (block-0 with 3 nodes: node-0, node-1, node-2; block-1 with 2 nodes: node-3, node-4)"),(0,a.kt)("li",{parentName:"ul"},"spine-1: 4 nodes (block-2 with 2 nodes: node-5, node-6; block-3 with 2 nodes: node-7, node-8)"),(0,a.kt)("li",{parentName:"ul"},"spine-2: 3 nodes (block-4 with 3 nodes: node-9, node-10, node-11)"))),(0,a.kt)("li",{parentName:"ul"},"Each node configuration: 8 CPU cores, 32 GiB Memory")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"ClusterTopologyLayer\n\u251c\u2500\u2500 SpineLayer: spine-0 (5 nodes)\n\u2502   \u251c\u2500\u2500 BlockLayer: block-0 (node-0, node-1, node-2)\n\u2502   \u2514\u2500\u2500 BlockLayer: block-1 (node-3, node-4)\n\u251c\u2500\u2500 SpineLayer: spine-1 (4 nodes)\n\u2502   \u251c\u2500\u2500 BlockLayer: block-2 (node-5, node-6)\n\u2502   \u2514\u2500\u2500 BlockLayer: block-3 (node-7, node-8)\n\u2514\u2500\u2500 SpineLayer: spine-2 (3 nodes)\n    \u2514\u2500\u2500 BlockLayer: block-4 (node-9, node-10, node-11)\n")),(0,a.kt)("p",null,"Our demonstration will include:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Example 1"),": Topology-aware scheduling with ",(0,a.kt)("inlineCode",{parentName:"li"},"PreferGather")," strategy and Binpack algorithm"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Example 2"),": ",(0,a.kt)("inlineCode",{parentName:"li"},"MustGather")," scheduling and topology-aware preemption when constraints cannot be satisfied")),(0,a.kt)("h3",{id:"example-1-topology-aware-scheduling-with-prefergather-and-binpack"},"Example 1: Topology-Aware Scheduling with ",(0,a.kt)("inlineCode",{parentName:"h3"},"PreferGather")," and Binpack"),(0,a.kt)("p",null,"This example demonstrates how Koordinator schedules pods with ",(0,a.kt)("inlineCode",{parentName:"p"},"PreferGather")," strategy to achieve both ",(0,a.kt)("strong",{parentName:"p"},"optimal network performance")," and ",(0,a.kt)("strong",{parentName:"p"},"minimal resource waste"),". The ",(0,a.kt)("inlineCode",{parentName:"p"},"PreferGather")," strategy ensures pods are gathered within the same topology domain for better network locality, while the Binpack algorithm selects the most compact domain to minimize resource fragmentation."),(0,a.kt)("h4",{id:"scenario"},"Scenario"),(0,a.kt)("p",null,"We will create a 4-pod training job when all 12 nodes are idle:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Each pod requires ",(0,a.kt)("strong",{parentName:"li"},"8 CPU cores")," (occupies entire node)"),(0,a.kt)("li",{parentName:"ul"},"Total requirement: 4 pods = 4 nodes"),(0,a.kt)("li",{parentName:"ul"},"The scheduler should select the most compact topology domain that provides:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Best network performance"),": Pods gathered in the same Spine for lower latency and higher bandwidth"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Least resource waste"),": The smallest topology domain that can accommodate all pods")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Expected result"),": Pods scheduled to ",(0,a.kt)("strong",{parentName:"p"},"spine-1")," (node-5 through node-8), which is the optimal choice because:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"It has exactly 4 nodes (perfect fit, zero waste)"),(0,a.kt)("li",{parentName:"ul"},"All pods are in the same Spine for optimal network performance"),(0,a.kt)("li",{parentName:"ul"},"No resource fragmentation in other Spines")),(0,a.kt)("h4",{id:"step-1-create-podgroup-with-prefergather-strategy"},"Step 1: Create PodGroup with ",(0,a.kt)("inlineCode",{parentName:"h4"},"PreferGather")," Strategy"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: scheduling.sigs.k8s.io/v1alpha1\nkind: PodGroup\nmetadata:\n  name: topology-demo-job\n  namespace: default\n  annotations:\n    gang.scheduling.koordinator.sh/network-topology-spec: |\n      {\n        "gatherStrategy": [\n          {\n            "layer": "BlockLayer",\n            "strategy": "PreferGather"\n          },\n          {\n            "layer": "SpineLayer",\n            "strategy": "PreferGather"\n          }\n        ]\n      }\nspec:\n  minMember: 4\n  scheduleTimeoutSeconds: 300\n')),(0,a.kt)("h4",{id:"step-2-create-4-pod-training-job"},"Step 2: Create 4-Pod Training Job"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: Pod\nmetadata:\n  name: training-pod-0\n  namespace: default\n  labels:\n    pod-group.scheduling.sigs.k8s.io: topology-demo-job\n  annotations:\n    gang.scheduling.koordinator.sh/network-topology-index: "0"\nspec:\n  schedulerName: koord-scheduler\n  containers:\n  - name: curlimage\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    command:\n    - sleep\n    - 365d\n    resources:\n      requests:\n        cpu: 8\n        memory: 32Gi\n      limits:\n        cpu: 8\n        memory: 32Gi\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n  restartPolicy: Always\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: training-pod-1\n  namespace: default\n  labels:\n    pod-group.scheduling.sigs.k8s.io: topology-demo-job\n  annotations:\n    gang.scheduling.koordinator.sh/network-topology-index: "1"\nspec:\n  schedulerName: koord-scheduler\n  containers:\n  - name: curlimage\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    command:\n    - sleep\n    - 365d\n    resources:\n      requests:\n        cpu: 8\n        memory: 32Gi\n      limits:\n        cpu: 8\n        memory: 32Gi\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n  restartPolicy: Always\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: training-pod-2\n  namespace: default\n  labels:\n    pod-group.scheduling.sigs.k8s.io: topology-demo-job\n  annotations:\n    gang.scheduling.koordinator.sh/network-topology-index: "2"\nspec:\n  schedulerName: koord-scheduler\n  containers:\n  - name: curlimage\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    command:\n    - sleep\n    - 365d\n    resources:\n      requests:\n        cpu: 8\n        memory: 32Gi\n      limits:\n        cpu: 8\n        memory: 32Gi\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n  restartPolicy: Always\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: training-pod-3\n  namespace: default\n  labels:\n    pod-group.scheduling.sigs.k8s.io: topology-demo-job\n  annotations:\n    gang.scheduling.koordinator.sh/network-topology-index: "3"\nspec:\n  schedulerName: koord-scheduler\n  containers:\n  - name: curlimage\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    command:\n    - sleep\n    - 365d\n    resources:\n      requests:\n        cpu: 8\n        memory: 32Gi\n      limits:\n        cpu: 8\n        memory: 32Gi\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n  restartPolicy: Always\n')),(0,a.kt)("h4",{id:"step-3-apply-and-verify-the-scheduling-result"},"Step 3: Apply and Verify the Scheduling Result"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f topology-demo-job.yaml\n")),(0,a.kt)("p",null,"After a few seconds, check the pod scheduling results:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -o wide | grep training-pod\n")),(0,a.kt)("p",null,"Expected output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"NAME            READY   STATUS    RESTARTS   AGE   IP            NODE      NOMINATED NODE\ntraining-pod-0  1/1     Running   0          30s   10.244.5.10   node-5    <none>\ntraining-pod-1  1/1     Running   0          30s   10.244.6.11   node-6    <none>\ntraining-pod-2  1/1     Running   0          30s   10.244.7.10   node-7    <none>\ntraining-pod-3  1/1     Running   0          30s   10.244.8.11   node-8    <none>\n")),(0,a.kt)("h4",{id:"how-the-binpack-algorithm-works"},"How the Binpack Algorithm Works"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Step 1: Calculate offerslots from bottom to top")),(0,a.kt)("p",null,"For each node (each pod requires 8 CPU cores to occupy the entire node):"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"All nodes (node-0 through node-11): offerslots = 1 (8 cores available / 8 cores per pod)")),(0,a.kt)("p",null,"For each Block:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"block-0 (node-0, node-1, node-2): offerslots = 3"),(0,a.kt)("li",{parentName:"ul"},"block-1 (node-3, node-4): offerslots = 2"),(0,a.kt)("li",{parentName:"ul"},"block-2 (node-5, node-6): offerslots = 2"),(0,a.kt)("li",{parentName:"ul"},"block-3 (node-7, node-8): offerslots = 2"),(0,a.kt)("li",{parentName:"ul"},"block-4 (node-9, node-10, node-11): offerslots = 3")),(0,a.kt)("p",null,"For each Spine:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"spine-0 (block-0, block-1): offerslots = 5"),(0,a.kt)("li",{parentName:"ul"},"spine-1 (block-2, block-3): offerslots = 4"),(0,a.kt)("li",{parentName:"ul"},"spine-2 (block-4): offerslots = 3")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Step 2: Find candidate topology nodes")),(0,a.kt)("p",null,"We need 4 pods (4 offerslots). Only spine-0 (5 slots) and spine-1 (4 slots) can accommodate the job."),(0,a.kt)("p",null,"At the Block level, no single block can accommodate all 4 pods, so candidates are at the Spine level."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Step 3: Apply Binpack algorithm")),(0,a.kt)("p",null,"Among the candidate spines:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"spine-0: offerslots = 5, required = 4, waste = 1"),(0,a.kt)("li",{parentName:"ul"},"spine-1: offerslots = 4, required = 4, waste = 0  \u2190 ",(0,a.kt)("strong",{parentName:"li"},"Selected (minimum waste)"))),(0,a.kt)("p",null,"The Binpack algorithm selects ",(0,a.kt)("strong",{parentName:"p"},"spine-1")," (node-5 through node-8), which has zero waste after placing all 4 pods."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Final placement"),": All 4 pods are scheduled to ",(0,a.kt)("strong",{parentName:"p"},"spine-1")," (node-5, node-6, node-7, node-8), achieving:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Optimal network performance (",(0,a.kt)("inlineCode",{parentName:"strong"},"PreferGather")," effect)"),": All pods are gathered within the same Spine (spine-1), minimizing cross-spine traffic and maximizing network bandwidth for inter-pod communication"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Minimal resource waste (Binpack effect)"),": spine-1 has exactly 4 slots for 4 pods (zero waste), while spine-0 would have 1 wasted slot. This leaves spine-0 with all 5 nodes available for future workloads, preventing resource fragmentation")),(0,a.kt)("h3",{id:"example-2-mustgather-and-topology-aware-preemption"},"Example 2: ",(0,a.kt)("inlineCode",{parentName:"h3"},"MustGather")," and Topology-Aware Preemption"),(0,a.kt)("p",null,"This example demonstrates why ",(0,a.kt)("inlineCode",{parentName:"p"},"MustGather")," is necessary for certain workloads and how preemption respects network topology constraints. "),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Why ",(0,a.kt)("inlineCode",{parentName:"strong"},"MustGather")," is required"),": In latency-sensitive distributed training scenarios, network communication patterns are extremely sensitive to latency. If pods are scattered across different Spines, cross-spine communication overhead can increase training time by 3-5x, making the job economically unfeasible. Therefore, ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"MustGather")," is not just an optimization\u2014it's a hard requirement")," for these workloads."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"How preemption respects topology"),": When ",(0,a.kt)("inlineCode",{parentName:"p"},"MustGather")," constraints cannot be satisfied due to insufficient resources, Koordinator performs ",(0,a.kt)("strong",{parentName:"p"},"topology-aware preemption"),". This means:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The scheduler identifies which low-priority pods need to be preempted"),(0,a.kt)("li",{parentName:"ol"},"Preemption decisions respect the same topology constraints as scheduling"),(0,a.kt)("li",{parentName:"ol"},"The scheduler ensures the freed resources can satisfy the ",(0,a.kt)("inlineCode",{parentName:"li"},"MustGather")," requirements"),(0,a.kt)("li",{parentName:"ol"},"Resources are reserved via ",(0,a.kt)("inlineCode",{parentName:"li"},"nominatedNode")," to prevent other pods from stealing them")),(0,a.kt)("h4",{id:"scenario-1"},"Scenario"),(0,a.kt)("p",null,"This example shows a scenario where:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Low-priority pods occupy node-0, node-1, and node-5 (each pod occupies entire node)"),(0,a.kt)("li",{parentName:"ol"},"A high-priority 4-pod job with ",(0,a.kt)("inlineCode",{parentName:"li"},"MustGather")," to SpineLayer is submitted (each pod occupies entire node)"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"No single Spine has 4 available nodes")," without preemption"),(0,a.kt)("li",{parentName:"ol"},"Koordinator performs topology-aware preemption: preempts the pod on node-5 and schedules all 4 high-priority pods to node-5 through node-8 (within spine-1), ",(0,a.kt)("strong",{parentName:"li"},"maintaining the ",(0,a.kt)("inlineCode",{parentName:"strong"},"MustGather")," constraint throughout the preemption process"))),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"3 low-priority pods already running on node-0, node-1, and node-5 (each occupying entire node with 8 cores)"),(0,a.kt)("li",{parentName:"ul"},"A high-priority 4-pod training job with strict network requirements:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Requires ",(0,a.kt)("inlineCode",{parentName:"strong"},"MustGather"))," to SpineLayer: Cross-spine latency would degrade performance by 3-5x"),(0,a.kt)("li",{parentName:"ul"},"Each pod requires ",(0,a.kt)("strong",{parentName:"li"},"8 CPU cores")," (occupies entire node)"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Current state"),": No single Spine has 4 available nodes",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"spine-0: 3 available nodes (node-2, node-3, node-4) - node-0, node-1 occupied"),(0,a.kt)("li",{parentName:"ul"},"spine-1: 3 available nodes (node-6, node-7, node-8) - node-5 occupied"),(0,a.kt)("li",{parentName:"ul"},"spine-2: 3 available nodes (node-9, node-10, node-11)")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Expected result"),": The scheduler performs ",(0,a.kt)("strong",{parentName:"p"},"topology-aware preemption"),", preempting the low-priority pod on node-5 to satisfy the ",(0,a.kt)("inlineCode",{parentName:"p"},"MustGather")," constraint, and schedules all 4 high-priority pods to ",(0,a.kt)("strong",{parentName:"p"},"spine-1")," (node-5 through node-8)."),(0,a.kt)("h4",{id:"step-1-define-priorityclasses"},"Step 1: Define PriorityClasses"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: scheduling.k8s.io/v1\nkind: PriorityClass\nmetadata:\n  name: high-priority\nvalue: 1000000\npreemptionPolicy: PreemptLowerPriority\ndescription: "High priority for critical training jobs"\n---\napiVersion: scheduling.k8s.io/v1\nkind: PriorityClass\nmetadata:\n  name: low-priority\nvalue: 1000\npreemptionPolicy: PreemptLowerPriority\ndescription: "Low priority for best-effort jobs"\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f priorityclasses.yaml\n")),(0,a.kt)("h4",{id:"step-2-create-low-priority-pods-on-node-0-node-1-and-node-5"},"Step 2: Create Low-Priority Pods on node-0, node-1, and node-5"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: Pod\nmetadata:\n  name: low-priority-pod-0\n  namespace: default\nspec:\n  schedulerName: koord-scheduler\n  priorityClassName: low-priority\n  nodeName: node-0\n  containers:\n  - name: curlimage\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    command:\n    - sleep\n    - 365d\n    resources:\n      requests:\n        cpu: 8\n        memory: 32Gi\n      limits:\n        cpu: 8\n        memory: 32Gi\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n  restartPolicy: Always\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: low-priority-pod-1\n  namespace: default\nspec:\n  schedulerName: koord-scheduler\n  priorityClassName: low-priority\n  nodeName: node-1\n  containers:\n  - name: curlimage\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    command:\n    - sleep\n    - 365d\n    resources:\n      requests:\n        cpu: 8\n        memory: 32Gi\n      limits:\n        cpu: 8\n        memory: 32Gi\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n  restartPolicy: Always\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: low-priority-pod-5\n  namespace: default\nspec:\n  schedulerName: koord-scheduler\n  priorityClassName: low-priority\n  nodeName: node-5\n  containers:\n  - name: curlimage\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    command:\n    - sleep\n    - 365d\n    resources:\n      requests:\n        cpu: 8\n        memory: 32Gi\n      limits:\n        cpu: 8\n        memory: 32Gi\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n  restartPolicy: Always\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f low-priority-pods.yaml\n")),(0,a.kt)("p",null,"Verify the pods are running:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -o wide\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE     NOMINATED NODE\nlow-priority-pod-0    1/1     Running   0          10s   10.244.0.10   node-0   <none>\nlow-priority-pod-1    1/1     Running   0          10s   10.244.1.10   node-1   <none>\nlow-priority-pod-5    1/1     Running   0          10s   10.244.5.10   node-5   <none>\n")),(0,a.kt)("h4",{id:"step-3-create-high-priority-job-with-mustgather-to-spinelayer"},"Step 3: Create High-Priority Job with ",(0,a.kt)("inlineCode",{parentName:"h4"},"MustGather")," to SpineLayer"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: scheduling.sigs.k8s.io/v1alpha1\nkind: PodGroup\nmetadata:\n  name: high-priority-training\n  namespace: default\n  annotations:\n    gang.scheduling.koordinator.sh/network-topology-spec: |\n      {\n        "gatherStrategy": [\n          {\n            "layer": "SpineLayer",\n            "strategy": "MustGather"\n          }\n        ]\n      }\nspec:\n  minMember: 4\n  scheduleTimeoutSeconds: 300\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: Pod\nmetadata:\n  name: hp-training-pod-0\n  namespace: default\n  labels:\n    pod-group.scheduling.sigs.k8s.io: high-priority-training\n  annotations:\n    gang.scheduling.koordinator.sh/network-topology-index: "0"\nspec:\n  schedulerName: koord-scheduler\n  priorityClassName: high-priority\n  preemptionPolicy: PreemptLowerPriority\n  containers:\n  - name: curlimage\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    command:\n    - sleep\n    - 365d\n    resources:\n      requests:\n        cpu: 8\n        memory: 32Gi\n      limits:\n        cpu: 8\n        memory: 32Gi\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n  restartPolicy: Always\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: hp-training-pod-1\n  namespace: default\n  labels:\n    pod-group.scheduling.sigs.k8s.io: high-priority-training\n  annotations:\n    gang.scheduling.koordinator.sh/network-topology-index: "1"\nspec:\n  schedulerName: koord-scheduler\n  priorityClassName: high-priority\n  preemptionPolicy: PreemptLowerPriority\n  containers:\n  - name: curlimage\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    command:\n    - sleep\n    - 365d\n    resources:\n      requests:\n        cpu: 8\n        memory: 32Gi\n      limits:\n        cpu: 8\n        memory: 32Gi\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n  restartPolicy: Always\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: hp-training-pod-2\n  namespace: default\n  labels:\n    pod-group.scheduling.sigs.k8s.io: high-priority-training\n  annotations:\n    gang.scheduling.koordinator.sh/network-topology-index: "2"\nspec:\n  schedulerName: koord-scheduler\n  priorityClassName: high-priority\n  preemptionPolicy: PreemptLowerPriority\n  containers:\n  - name: curlimage\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    command:\n    - sleep\n    - 365d\n    resources:\n      requests:\n        cpu: 8\n        memory: 32Gi\n      limits:\n        cpu: 8\n        memory: 32Gi\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n  restartPolicy: Always\n---\napiVersion: v1\nkind: Pod\nmetadata:\n  name: hp-training-pod-3\n  namespace: default\n  labels:\n    pod-group.scheduling.sigs.k8s.io: high-priority-training\n  annotations:\n    gang.scheduling.koordinator.sh/network-topology-index: "3"\nspec:\n  schedulerName: koord-scheduler\n  priorityClassName: high-priority\n  preemptionPolicy: PreemptLowerPriority\n  containers:\n  - name: curlimage\n    image: busybox\n    imagePullPolicy: IfNotPresent\n    command:\n    - sleep\n    - 365d\n    resources:\n      requests:\n        cpu: 8\n        memory: 32Gi\n      limits:\n        cpu: 8\n        memory: 32Gi\n    terminationMessagePath: /dev/termination-log\n    terminationMessagePolicy: File\n  restartPolicy: Always\n')),(0,a.kt)("h4",{id:"step-4-apply-and-observe-preemption"},"Step 4: Apply and Observe Preemption"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f high-priority-training.yaml\n")),(0,a.kt)("p",null,"Immediately after submitting, check the pod status:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -o wide\n")),(0,a.kt)("p",null,"Expected output during preemption:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"NAME                  READY   STATUS        RESTARTS   AGE   IP            NODE     NOMINATED NODE\nlow-priority-pod-0    1/1     Running       0          2m    10.244.0.10   node-0   <none>\nlow-priority-pod-1    1/1     Running       0          2m    10.244.1.10   node-1   <none>\nlow-priority-pod-5    0/1     Terminating   0          2m    10.244.5.10   node-5   <none>\nhp-training-pod-0     0/1     Pending       0          10s   <none>        <none>   node-5\nhp-training-pod-1     0/1     Pending       0          10s   <none>        <none>   node-6\nhp-training-pod-2     0/1     Pending       0          10s   <none>        <none>   node-7\nhp-training-pod-3     0/1     Pending       0          10s   <none>        <none>   node-8\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Understanding Scheduler Messages During Topology-Aware Preemption")),(0,a.kt)("p",null,"While the preemption is in progress (before the victim pod fully terminates), the high-priority pods will be in ",(0,a.kt)("inlineCode",{parentName:"p"},"Pending")," state. You can inspect the detailed scheduler messages:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pod hp-training-pod-0 -o yaml\n")),(0,a.kt)("p",null,"The pod status will contain informative messages explaining why scheduling is waiting:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'status:\n  conditions:\n  - lastProbeTime: null\n    lastTransitionTime: "2025-10-23T07:35:30Z"\n    message: \'0/12 nodes are available: no candidate topology nodes can accommodate\n      job, desiredOfferSlot: 4, topology topologyNode SpineLayer/spine-0: 3;topology\n      topologyNode SpineLayer/spine-1: 3;topology topologyNode SpineLayer/spine-2:\n      3. preemption: not eligible due to terminating pod on the nominated node..\'\n    reason: Unschedulable\n    status: "False"\n    type: PodScheduled\n  nominatedNodeName: node-5\n  phase: Pending\n')),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Key information in the message:")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Topology constraint evaluation"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"no candidate topology nodes can accommodate job, desiredOfferSlot: 4")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The job requires 4 slots (nodes) within a single topology domain"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Per-Spine availability"),": "),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"topology topologyNode SpineLayer/spine-0: 3")," - Only 3 available nodes"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"topology topologyNode SpineLayer/spine-1: 3")," - Only 3 available nodes"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"topology topologyNode SpineLayer/spine-2: 3")," - Only 3 available nodes"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"None of the Spines can satisfy the ",(0,a.kt)("inlineCode",{parentName:"strong"},"MustGather")," requirement without preemption")))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Preemption status"),": ",(0,a.kt)("inlineCode",{parentName:"p"},"preemption: not eligible due to terminating pod on the nominated node")),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Preemption has been triggered for low-priority-pod-5 on node-5"),(0,a.kt)("li",{parentName:"ul"},"The scheduler is waiting for the victim pod to fully terminate"),(0,a.kt)("li",{parentName:"ul"},"Resources have been reserved via ",(0,a.kt)("inlineCode",{parentName:"li"},"nominatedNodeName: node-5")))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"GangGroup coordination"),": Other member pods (hp-training-pod-1, hp-training-pod-2, hp-training-pod-3) will show similar messages, indicating they're waiting due to the GangGroup constraint:"))),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'message: \'GangGroup "default/high-priority-training" gets rejected due to member Pod \n  "default/hp-training-pod-0" is unschedulable with reason "no candidate topology nodes \n  can accommodate job, desiredOfferSlot: 4...", alreadyWaitForBound: 0. preemption: \n  preemption already attempted by default/hp-training-pod-0 with message not eligible \n  due to terminating pod on the nominated node..\'\n')),(0,a.kt)("p",null,"This message confirms that:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"All pods in the GangGroup wait together (gang scheduling semantics)"),(0,a.kt)("li",{parentName:"ul"},"Preemption is coordinated at the job level"),(0,a.kt)("li",{parentName:"ul"},"Topology constraints are enforced throughout the preemption process")),(0,a.kt)("h4",{id:"step-5-verify-final-scheduling-result"},"Step 5: Verify Final Scheduling Result"),(0,a.kt)("p",null,"After the low-priority pod on node-5 terminates, check again:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get pods -o wide\n")),(0,a.kt)("p",null,"Expected final output:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"NAME                  READY   STATUS    RESTARTS   AGE   IP            NODE     NOMINATED NODE\nlow-priority-pod-0    1/1     Running   0          3m    10.244.0.10   node-0   <none>\nlow-priority-pod-1    1/1     Running   0          3m    10.244.1.10   node-1   <none>\nhp-training-pod-0     1/1     Running   0          45s   10.244.5.20   node-5   <none>\nhp-training-pod-1     1/1     Running   0          45s   10.244.6.20   node-6   <none>\nhp-training-pod-2     1/1     Running   0          45s   10.244.7.20   node-7   <none>\nhp-training-pod-3     1/1     Running   0          45s   10.244.8.20   node-8   <none>\n")),(0,a.kt)("h4",{id:"how-topology-aware-preemption-works"},"How Topology-Aware Preemption Works"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Step 1: Identify topology requirements and validate ",(0,a.kt)("inlineCode",{parentName:"strong"},"MustGather")," constraint")),(0,a.kt)("p",null,"The high-priority job requires all 4 pods to be in the same Spine (",(0,a.kt)("inlineCode",{parentName:"p"},"MustGather")," to SpineLayer). This is a ",(0,a.kt)("strong",{parentName:"p"},"hard constraint"),"\u2014the job cannot run if this requirement is not met. Each pod requires 8 CPU cores (entire node)."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Step 2: Evaluate available resources per Spine (respecting topology)")),(0,a.kt)("p",null,"Current cluster state:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"spine-0 (5 nodes):",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"node-0: Occupied by low-priority-pod-0 (8 cores used, 0 cores available)"),(0,a.kt)("li",{parentName:"ul"},"node-1: Occupied by low-priority-pod-1 (8 cores used, 0 cores available)"),(0,a.kt)("li",{parentName:"ul"},"node-2: Available (8 cores)"),(0,a.kt)("li",{parentName:"ul"},"node-3: Available (8 cores)"),(0,a.kt)("li",{parentName:"ul"},"node-4: Available (8 cores)"),(0,a.kt)("li",{parentName:"ul"},"Total: 3 nodes available (need 4 for the job)"))),(0,a.kt)("li",{parentName:"ul"},"spine-1 (4 nodes):",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"node-5: Occupied by low-priority-pod-5 (8 cores used, 0 cores available)"),(0,a.kt)("li",{parentName:"ul"},"node-6: Available (8 cores)"),(0,a.kt)("li",{parentName:"ul"},"node-7: Available (8 cores)"),(0,a.kt)("li",{parentName:"ul"},"node-8: Available (8 cores)"),(0,a.kt)("li",{parentName:"ul"},"Total: 3 nodes available (need 4 for the job)"))),(0,a.kt)("li",{parentName:"ul"},"spine-2 (3 nodes):",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"node-9: Available (8 cores)"),(0,a.kt)("li",{parentName:"ul"},"node-10: Available (8 cores)"),(0,a.kt)("li",{parentName:"ul"},"node-11: Available (8 cores)"),(0,a.kt)("li",{parentName:"ul"},"Total: 3 nodes available (cannot accommodate 4 pods even with preemption)")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Key observation"),": No single Spine has enough available resources without preemption. ",(0,a.kt)("strong",{parentName:"p"},"The scheduler must perform topology-aware preemption to satisfy the ",(0,a.kt)("inlineCode",{parentName:"strong"},"MustGather")," constraint.")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Step 3: Determine topology-aware preemption strategy")),(0,a.kt)("p",null,"The scheduler evaluates minimal preemption options ",(0,a.kt)("strong",{parentName:"p"},"while respecting the SpineLayer topology constraint"),":"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"spine-0"),": Would need to preempt 1 node (either node-0 or node-1), resulting in 4 available nodes",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Preemption count: 1 pod"),(0,a.kt)("li",{parentName:"ul"},"After preemption: Can satisfy ",(0,a.kt)("inlineCode",{parentName:"li"},"MustGather")," to SpineLayer"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"spine-1"),": Would need to preempt 1 node (node-5), resulting in 4 available nodes",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Preemption count: 1 pod"),(0,a.kt)("li",{parentName:"ul"},"After preemption: Can satisfy ",(0,a.kt)("inlineCode",{parentName:"li"},"MustGather")," to SpineLayer"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"spine-2"),": Cannot accommodate 4 pods (only 3 nodes total)",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Not a valid candidate")))),(0,a.kt)("p",null,"Both spine-0 and spine-1 require the same amount of preemption (1 pod). The Binpack algorithm chooses ",(0,a.kt)("strong",{parentName:"p"},"spine-1")," because:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"It has exactly 4 nodes (perfect fit, zero waste)"),(0,a.kt)("li",{parentName:"ol"},"After preempting node-5: all 4 nodes in spine-1 become available"),(0,a.kt)("li",{parentName:"ol"},"This satisfies the ",(0,a.kt)("inlineCode",{parentName:"li"},"MustGather")," constraint with minimal disruption")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Step 4: Execute topology-aware preemption")),(0,a.kt)("p",null,"Koordinator performs preemption ",(0,a.kt)("strong",{parentName:"p"},"while maintaining topology constraints"),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Marks low-priority-pod-5 for preemption (sets DisruptionTarget condition)"),(0,a.kt)("li",{parentName:"ol"},"Sets ",(0,a.kt)("inlineCode",{parentName:"li"},"nominatedNode")," for all 4 high-priority pods to nodes ",(0,a.kt)("strong",{parentName:"li"},"within spine-1")," (node-5 through node-8)",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"This ensures topology constraints are preserved during resource reservation"))),(0,a.kt)("li",{parentName:"ol"},"Deletes low-priority-pod-5"),(0,a.kt)("li",{parentName:"ol"},"Schedules all high-priority pods to spine-1, ",(0,a.kt)("strong",{parentName:"li"},"satisfying the ",(0,a.kt)("inlineCode",{parentName:"strong"},"MustGather")," constraint"))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Key takeaways:")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"MustGather")," is a hard requirement"),": For latency-sensitive workloads like Tensor Parallelism training, ",(0,a.kt)("inlineCode",{parentName:"p"},"MustGather")," is not optional\u2014it's essential for acceptable performance. Cross-spine communication would make the job 3-5x slower.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Preemption respects topology constraints"),": When ",(0,a.kt)("inlineCode",{parentName:"p"},"MustGather")," cannot be satisfied with available resources, the scheduler performs ",(0,a.kt)("strong",{parentName:"p"},"topology-aware preemption"),". It evaluates preemption candidates ",(0,a.kt)("strong",{parentName:"p"},"within each topology domain")," (Spine) separately, ensuring the final placement satisfies the topology requirements.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Minimal disruption"),": The scheduler preempted only 1 pod (the minimum necessary) to satisfy the ",(0,a.kt)("inlineCode",{parentName:"p"},"MustGather")," constraint, choosing spine-1 because it's a perfect fit (4 nodes for 4 pods).")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Resource reservation maintains topology"),": The ",(0,a.kt)("inlineCode",{parentName:"p"},"nominatedNode")," mechanism reserves resources ",(0,a.kt)("strong",{parentName:"p"},"within the selected topology domain")," (spine-1), preventing other pods from breaking the topology constraint during the preemption process.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"End-to-end topology guarantee"),": From preemption decision through resource reservation to final scheduling, the entire process maintains the ",(0,a.kt)("inlineCode",{parentName:"p"},"MustGather")," constraint, ensuring all 4 pods are placed within spine-1."))),(0,a.kt)("h2",{id:"advanced-configuration"},"Advanced Configuration"),(0,a.kt)("h3",{id:"topology-layer-naming-conventions"},"Topology Layer Naming Conventions"),(0,a.kt)("p",null,"It's recommended to use clear naming conventions to identify topology layers:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"# Recommended layer naming\nNodeTopologyLayer       # Node layer\nAcceleratorLayer        # Accelerator interconnection layer (e.g., NVLink)\nBlockLayer              # Block switch layer\nSpineLayer              # Spine switch layer\nDatacenterLayer         # Datacenter layer\n")),(0,a.kt)("h3",{id:"topology-strategy-selection-guide"},"Topology Strategy Selection Guide"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Strategy"),(0,a.kt)("th",{parentName:"tr",align:null},"Use Case"),(0,a.kt)("th",{parentName:"tr",align:null},"Behavior"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"PreferGather")),(0,a.kt)("td",{parentName:"tr",align:null},"Topology Layer need good network performance but can tolerate some dispersion"),(0,a.kt)("td",{parentName:"tr",align:null},"Gather as much as possible, but allow dispersion when resources are insufficient")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("inlineCode",{parentName:"td"},"MustGather")),(0,a.kt)("td",{parentName:"tr",align:null},"Topology Layer with strict network bandwidth requirements"),(0,a.kt)("td",{parentName:"tr",align:null},"Must gather in the specified layer, otherwise scheduling fails")))),(0,a.kt)("h3",{id:"multi-podgroup-coordinated-scheduling"},"Multi-PodGroup Coordinated Scheduling"),(0,a.kt)("p",null,"For complex training jobs containing master and worker, use ",(0,a.kt)("inlineCode",{parentName:"p"},"GangGroup")," semantics:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: scheduling.sigs.k8s.io/v1alpha1\nkind: PodGroup\nmetadata:\n  annotations:\n    gang.scheduling.koordinator.sh/groups: |\n      ["default/llm-master", "default/llm-worker"]\n    gang.scheduling.koordinator.sh/network-topology-spec: |\n      {\n        "gatherStrategy": [\n          {\n            "layer": "SpineLayer",\n            "strategy": "MustGather"\n          }\n        ]\n      }\n')),(0,a.kt)("p",null,"Ensure all related PodGroups use the same ",(0,a.kt)("inlineCode",{parentName:"p"},"gang.scheduling.koordinator.sh/groups")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"gang.scheduling.koordinator.sh/network-topology-spec")," annotation."),(0,a.kt)("h2",{id:"troubleshooting"},"Troubleshooting"),(0,a.kt)("h3",{id:"pod-stuck-in-pending-state"},"Pod Stuck in Pending State"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Possible Cause"),": Network topology constraints are too strict, not enough nodes satisfy the requirements"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Solution"),": "),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Check cluster topology configuration: ",(0,a.kt)("inlineCode",{parentName:"li"},"kubectl get clusternetworktopology default -o yaml")),(0,a.kt)("li",{parentName:"ul"},"Relax topology strategy, change ",(0,a.kt)("inlineCode",{parentName:"li"},"MustGather")," to ",(0,a.kt)("inlineCode",{parentName:"li"},"PreferGather")),(0,a.kt)("li",{parentName:"ul"},"Add cluster nodes or adjust node topology labels")),(0,a.kt)("h3",{id:"topology-aware-scheduling-not-taking-effect"},"Topology-Aware Scheduling Not Taking Effect"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Troubleshooting Steps"),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Verify if Koord-Scheduler has the network topology plugin enabled:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl -n koordinator-system get cm koord-scheduler-config -o yaml\n")),(0,a.kt)("ol",{start:2},(0,a.kt)("li",{parentName:"ol"},"Check if nodes have the correct topology labels:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get nodes --show-labels | grep network.topology\n")),(0,a.kt)("ol",{start:3},(0,a.kt)("li",{parentName:"ol"},"Check ClusterNetworkTopology status:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get clusternetworktopology default -o yaml\n")),(0,a.kt)("h3",{id:"preemption-not-occurring-as-expected"},"Preemption Not Occurring as Expected"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Check"),":"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Confirm PriorityClass is configured correctly"),(0,a.kt)("li",{parentName:"ol"},"Check Pod's ",(0,a.kt)("inlineCode",{parentName:"li"},"preemptionPolicy")," setting"),(0,a.kt)("li",{parentName:"ol"},"View scheduler logs:")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl -n koordinator-system logs -l component=koord-scheduler --tail=100\n")),(0,a.kt)("h2",{id:"best-practices"},"Best Practices"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Start with ",(0,a.kt)("inlineCode",{parentName:"strong"},"PreferGather")," strategy"),": For initial deployments, use ",(0,a.kt)("inlineCode",{parentName:"p"},"PreferGather")," to understand pod placement patterns before applying strict ",(0,a.kt)("inlineCode",{parentName:"p"},"MustGather")," constraints")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Use topology indices for distributed training"),": Always assign ",(0,a.kt)("inlineCode",{parentName:"p"},"gang.scheduling.koordinator.sh/network-topology-index")," annotations to establish clear communication patterns in data-parallel jobs")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Choose appropriate topology layers"),":"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"For latency-sensitive inference services: ",(0,a.kt)("inlineCode",{parentName:"li"},"MustGather")," + ",(0,a.kt)("inlineCode",{parentName:"li"},"BlockLayer")),(0,a.kt)("li",{parentName:"ul"},"For large-scale LLM training: ",(0,a.kt)("inlineCode",{parentName:"li"},"MustGather")," + ",(0,a.kt)("inlineCode",{parentName:"li"},"SpineLayer")),(0,a.kt)("li",{parentName:"ul"},"For general distributed training: ",(0,a.kt)("inlineCode",{parentName:"li"},"PreferGather")," combination across multiple layers"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Combine with priorities for critical workloads"),": Set high priorities for production training jobs to ensure they can preempt lower-priority jobs while maintaining topology constraints")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Monitor topology distribution"),": Regularly check pod placement patterns and adjust topology strategies based on actual network performance metrics")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Plan for preemption scenarios"),": When using ",(0,a.kt)("inlineCode",{parentName:"p"},"MustGather"),", ensure there's enough capacity in at least one topology domain to avoid scheduling failures"))),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../architecture/job"},"Job Architecture")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../user-manuals/job-level-preemption"},"Job Level Preemption")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../user-manuals/gang-scheduling"},"Gang Scheduling")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/koordinator-sh/koordinator/blob/main/docs/proposals/scheduling/20250611-networktopology-aware-scheduling.md"},"Network Topology Proposal"))))}u.isMDXComponent=!0}}]);