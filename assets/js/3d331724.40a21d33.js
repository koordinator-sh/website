"use strict";(self.webpackChunkkoordinator_sh=self.webpackChunkkoordinator_sh||[]).push([[684],{3905:function(e,t,o){o.d(t,{Zo:function(){return d},kt:function(){return u}});var r=o(7294);function n(e,t,o){return t in e?Object.defineProperty(e,t,{value:o,enumerable:!0,configurable:!0,writable:!0}):e[t]=o,e}function a(e,t){var o=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),o.push.apply(o,r)}return o}function i(e){for(var t=1;t<arguments.length;t++){var o=null!=arguments[t]?arguments[t]:{};t%2?a(Object(o),!0).forEach((function(t){n(e,t,o[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(o)):a(Object(o)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(o,t))}))}return e}function l(e,t){if(null==e)return{};var o,r,n=function(e,t){if(null==e)return{};var o,r,n={},a=Object.keys(e);for(r=0;r<a.length;r++)o=a[r],t.indexOf(o)>=0||(n[o]=e[o]);return n}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)o=a[r],t.indexOf(o)>=0||Object.prototype.propertyIsEnumerable.call(e,o)&&(n[o]=e[o])}return n}var s=r.createContext({}),c=function(e){var t=r.useContext(s),o=t;return e&&(o="function"==typeof e?e(t):i(i({},t),e)),o},d=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var o=e.components,n=e.mdxType,a=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),p=c(o),u=n,m=p["".concat(s,".").concat(u)]||p[u]||h[u]||a;return o?r.createElement(m,i(i({ref:t},d),{},{components:o})):r.createElement(m,i({ref:t},d))}));function u(e,t){var o=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=o.length,i=new Array(a);i[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,i[1]=l;for(var c=2;c<a;c++)i[c]=o[c];return r.createElement.apply(null,i)}return r.createElement.apply(null,o)}p.displayName="MDXCreateElement"},9525:function(e,t,o){o.r(t),o.d(t,{assets:function(){return d},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return l},metadata:function(){return c},toc:function(){return h}});var r=o(7462),n=o(3366),a=(o(7294),o(3905)),i=["components"],l={slug:"release-v0.2.0",title:"Koordinator v0.2.0 - Enhanced node-side scheduling capabilities",authors:["joseph"],tags:["koordinator","colocation","kubernetes","scheduling","orchestration","release"]},s=void 0,c={permalink:"/blog/release-v0.2.0",editUrl:"https://github.com/koordinator-sh/koordinator.sh/edit/main/blog/2022-04-19-release/index.md",source:"@site/blog/2022-04-19-release/index.md",title:"Koordinator v0.2.0 - Enhanced node-side scheduling capabilities",description:"We\u2019re pleased to announce the release of Koordinator v0.2.0.",date:"2022-04-19T00:00:00.000Z",formattedDate:"April 19, 2022",tags:[{label:"koordinator",permalink:"/blog/tags/koordinator"},{label:"colocation",permalink:"/blog/tags/colocation"},{label:"kubernetes",permalink:"/blog/tags/kubernetes"},{label:"scheduling",permalink:"/blog/tags/scheduling"},{label:"orchestration",permalink:"/blog/tags/orchestration"},{label:"release",permalink:"/blog/tags/release"}],readingTime:3.445,truncated:!1,authors:[{name:"Joseph",title:"Koordinator maintainer",url:"https://github.com/eahydra",imageURL:"https://github.com/eahydra.png",key:"joseph"}],frontMatter:{slug:"release-v0.2.0",title:"Koordinator v0.2.0 - Enhanced node-side scheduling capabilities",authors:["joseph"],tags:["koordinator","colocation","kubernetes","scheduling","orchestration","release"]},nextItem:{title:"Koordinator v0.1.0 - QoS based scheduling system",permalink:"/blog/release-v0.1.0"}},d={authorsImageUrls:[void 0]},h=[{value:"Overview",id:"overview",level:2},{value:"Install or Upgrade to Koordinator v0.2.0",id:"install-or-upgrade-to-koordinator-v020",level:2},{value:"Install with helms",id:"install-with-helms",level:3},{value:"Upgrade with helm",id:"upgrade-with-helm",level:3},{value:"Isolate resources for best-effort workloads",id:"isolate-resources-for-best-effort-workloads",level:2},{value:"Active eviction mechanism based on memory safety thresholds",id:"active-eviction-mechanism-based-on-memory-safety-thresholds",level:2},{value:"CPU Burst - Improve the performance of latency-sensitive applications",id:"cpu-burst---improve-the-performance-of-latency-sensitive-applications",level:2},{value:"More",id:"more",level:2}],p={toc:h};function u(e){var t=e.components,o=(0,n.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"We\u2019re pleased to announce the release of Koordinator v0.2.0."),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"Koordinator v0.1.0 implements basic co-location scheduling capabilities, and after the project was released, it has received attention and positive responses from the community.\nFor some issues that everyone cares about, such as how to isolate resources for best-effort workloads, how to ensure the runtime stability of latency-sensitiv applications in co-location scenarios, etc., we have enhanced node-side scheduling capabilities in koordinator v0.2.0 to solve these problems."),(0,a.kt)("h2",{id:"install-or-upgrade-to-koordinator-v020"},"Install or Upgrade to Koordinator v0.2.0"),(0,a.kt)("h3",{id:"install-with-helms"},"Install with helms"),(0,a.kt)("p",null,"Koordinator can be simply installed by helm v3.5+, which is a simple command-line tool and you can get it from ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/helm/helm/releases"},"here"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"# Firstly add koordinator charts repository if you haven't do this.\n$ helm repo add koordinator-sh https://koordinator-sh.github.io/charts/\n\n# [Optional]\n$ helm repo update\n\n# Install the latest version.\n$ helm install koordinator koordinator-sh/koordinator --version 0.2.0\n")),(0,a.kt)("h3",{id:"upgrade-with-helm"},"Upgrade with helm"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"# Firstly add koordinator charts repository if you haven't do this.\n$ helm repo add koordinator-sh https://koordinator-sh.github.io/charts/\n\n# [Optional]\n$ helm repo update\n\n# Upgrade the latest version.\n$ helm upgrade koordinator koordinator-sh/koordinator --version 0.2.0 [--force]\n")),(0,a.kt)("p",null,"For more details, please refer to the ",(0,a.kt)("a",{parentName:"p",href:"/docs/installation"},"installation manual"),"."),(0,a.kt)("h2",{id:"isolate-resources-for-best-effort-workloads"},"Isolate resources for best-effort workloads"),(0,a.kt)("p",null,"In Koodinator v0.2.0, we refined the ability to isolate resources for best-effort worklods. "),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"koordlet")," will set the cgroup parameters according to the resources described in the Pod Spec. Currently supports setting CPU Request/Limit, and Memory Limit."),(0,a.kt)("p",null,"For CPU resources, only the case of ",(0,a.kt)("inlineCode",{parentName:"p"},"request == limit")," is supported, and the support for the scenario of ",(0,a.kt)("inlineCode",{parentName:"p"},"request <= limit")," will be supported in the next version."),(0,a.kt)("h2",{id:"active-eviction-mechanism-based-on-memory-safety-thresholds"},"Active eviction mechanism based on memory safety thresholds"),(0,a.kt)("p",null,"When latency-sensitiv applications are serving, memory usage may increase due to bursty traffic. Similarly, there may be similar scenarios for best-effort workloads, for example, the current computing load exceeds the expected resource Request/Limit. "),(0,a.kt)("p",null,"These scenarios will lead to an increase in the overall memory usage of the node, which will have an unpredictable impact on the runtime stability of the node side. For example, it can reduce the quality of service of latency-sensitiv applications or even become unavailable. Especially in a co-location environment, it is more challenging."),(0,a.kt)("p",null,"We implemented an active eviction mechanism based on memory safety thresholds in Koodinator. "),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"koordlet")," will regularly check the recent memory usage of node and Pods to check whether the safty threshold is exceeded. If it exceeds, it will evict some best-effort Pods to release memory. This mechanism can better ensure the stability of node and latency-sensitiv applications."),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"koordlet")," currently only evicts best-effort Pods, sorted according to the Priority specified in the Pod Spec. The lower the priority, the higher the priority to be evicted, the same priority will be sorted according to the memory usage rate (RSS), the higher the memory usage, the higher the priority to be evicted. This eviction selection algorithm is not static. More dimensions will be considered in the future, and more refined implementations will be implemented for more scenarios to achieve more reasonable evictions."),(0,a.kt)("p",null,"The current memory utilization safety threshold default value is 70%. You can modify the ",(0,a.kt)("inlineCode",{parentName:"p"},"memoryEvictThresholdPercent")," in ConfigMap ",(0,a.kt)("inlineCode",{parentName:"p"},"slo-controller-config")," according to the actual situation, "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: slo-controller-config\n  namespace: koordinator-system\ndata:\n  colocation-config: |\n    {\n      "enable": true\n    }\n  resource-threshold-config: |\n    {\n      "clusterStrategy": {\n        "enable": true,\n        "memoryEvictThresholdPercent": 70\n      }\n    }\n')),(0,a.kt)("h2",{id:"cpu-burst---improve-the-performance-of-latency-sensitive-applications"},"CPU Burst - Improve the performance of latency-sensitive applications"),(0,a.kt)("p",null,"CPU Burst is a service level objective (SLO)-aware resource scheduling feature. You can use CPU Burst to improve the performance of latency-sensitive applications. CPU scheduling for a container may be throttled by the kernel due to the CPU limit, which downgrades the performance of the application. Koordinator automatically detects CPU throttling events and automatically adjusts the CPU limit to a proper value. This greatly improves the performance of latency-sensitive applications. "),(0,a.kt)("p",null,"The main code of the CPU Burst function has been merged into the main branch and will be released in the next version. If you want to use this ability early, you are welcome to participate in Koordiantor and improve it together."),(0,a.kt)("h2",{id:"more"},"More"),(0,a.kt)("p",null,"Fore More details, please refer to the ",(0,a.kt)("a",{parentName:"p",href:"/docs"},"Documentation"),". Hope it helps!"))}u.isMDXComponent=!0}}]);